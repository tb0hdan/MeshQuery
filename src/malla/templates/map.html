{% extends "base.html" %}
{% from "components/sidebar_macros.html" import sidebar_container, selected_details_section, search_section, controls_section, stats_section, legend_section, sidebar_styles %}

{% block title %}Node Map - Malla{% endblock %}

{% block extra_css %}
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<!-- Leaflet MarkerCluster CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
{% endblock %}

{% block content %}
<!-- Override the base template's container to make this page full-width/full-height -->
</div> <!-- Close the base template's container -->

<div class="map-container">
    <!-- Main Map Area -->
    <div class="map-main">
        <div id="mapLoading" class="loading-overlay">
            <div class="spinner-border text-primary" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
            <p class="mt-2 text-muted">Loading node locations...</p>
        </div>
        <div id="map" class="network-map"></div>
        <div id="mapError" class="error-overlay" style="display: none;">
            <i class="bi bi-exclamation-triangle"></i>
            <p class="mt-2">Error loading map data</p>
        </div>
    </div>

    <!-- Sidebar -->
    {% call sidebar_container("sidebar", "Network Map", "bi bi-map", "toggleSidebar") %}
        {{ selected_details_section("clearSelection") }}

        <!-- Node Search and List Combined -->
        <div class="sidebar-section">
            <h6><i class="bi bi-search"></i> Search & Filter Nodes</h6>
            <div class="input-group input-group-sm mb-2">
                <input type="text" class="form-control" id="nodeSearch" placeholder="Search by node name or ID...">
                <button class="btn btn-outline-secondary" type="button" id="clearSearch">
                    <i class="bi bi-x"></i>
                </button>
            </div>

            <!-- Combined search results and node list -->
            <div id="nodeListContainer" class="node-list-container">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <small class="text-muted">Nodes (<span id="nodeCount">0</span>)</small>
                    <small class="text-muted" id="searchResultsCount" style="display: none;">
                        <span id="searchCount">0</span> results
                    </small>
                </div>
                <div id="nodeList" class="node-list">
                    <div class="text-center text-muted py-4">
                        <div class="spinner-border spinner-border-sm" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                        <p class="mt-2 small">Loading nodes...</p>
                    </div>
                </div>
            </div>
        </div>

        {% set map_controls = [
            {"class": "btn-outline-secondary", "onclick": "fitMapToNodes()", "icon": "bi bi-arrows-move", "text": "Fit All Nodes"},
            {"class": "btn-outline-primary", "onclick": "refreshMap()", "icon": "bi bi-arrow-clockwise", "text": "Refresh"}
        ] %}
        {{ controls_section(map_controls) }}

        <!-- Filters -->
        <div class="sidebar-section">
            <h6><i class="bi bi-funnel"></i> Filters</h6>
            <form id="locationFilterForm">
                <div class="mb-3">
                    <label for="maxAge" class="form-label">Max Age</label>
                    <select class="form-select form-select-sm" id="maxAge" name="maxAge">
                        <option value="">No Limit</option>
                        <option value="1">1 Hour</option>
                        <option value="6">6 Hours</option>
                        <option value="24">24 Hours</option>
                        <option value="72">3 Days</option>
                        <option value="168">1 Week</option>
                    </select>
                </div>
                <div class="mb-3">
                    <label for="roleFilter" class="form-label">Node Role</label>
                    <select class="form-select form-select-sm" id="roleFilter" name="roleFilter">
                        <option value="">All Roles</option>
                        <option value="CLIENT">Client</option>
                        <option value="ROUTER">Router</option>
                        <option value="ROUTER_LATE">Router Late</option>
                        <option value="REPEATER">Repeater</option>
                        <option value="CLIENT_MUTE">Client Mute</option>
                        <option value="ROUTER_CLIENT">Router Client</option>
                        <option value="SENSOR">Sensor</option>
                        <option value="UNKNOWN">Unknown/Other</option>
                    </select>
                </div>
                <div class="mb-3">
                    <label for="channelFilter" class="form-label">Primary Channel</label>
                    <select class="form-select form-select-sm" id="channelFilter" name="channelFilter">
                        <option value="">All Channels</option>
                        <!-- Options loaded dynamically -->
                    </select>
                </div>
                <div class="mb-3">
                    <label for="startDateTime" class="form-label">Start Date & Time</label>
                    <input type="datetime-local" class="form-control form-control-sm" id="startDateTime" name="startDateTime">
                </div>
                <div class="mb-3">
                    <label for="endDateTime" class="form-label">End Date & Time</label>
                    <input type="datetime-local" class="form-control form-control-sm" id="endDateTime" name="endDateTime">
                </div>
                <div class="d-flex justify-content-end mb-2">
                    <button type="button" class="btn btn-sm btn-outline-secondary" id="clearDateRange">
                        <i class="bi bi-x-circle"></i> Clear Dates
                    </button>
                </div>
                <div class="mb-3">
                    <label for="minContacts" class="form-label">Min Contacts</label>
                    <input type="number" class="form-control form-control-sm" id="minContacts" name="minContacts" value="1" min="1">
                </div>
                <button type="submit" class="btn btn-primary btn-sm w-100">
                    <i class="bi bi-funnel"></i> Apply Filters
                </button>
            </form>
        </div>

        <!-- Map Stats -->
        <div class="sidebar-section">
            <h6><i class="bi bi-bar-chart"></i> Statistics</h6>
            <div id="mapStats" class="stats-content">
                <div><strong>Nodes:</strong> <span id="statsNodes">0</span></div>
                <div><strong>With Location:</strong> <span id="statsWithLocation">0</span></div>
                <div><strong>RF Links:</strong> <span id="statsLinks">0</span></div>
                <div><strong>Last Update:</strong> <span id="statsLastUpdate">--</span></div>
            </div>
        </div>

        <!-- Link visibility checkboxes -->
        <div class="sidebar-section">
            <h6><i class="bi bi-diagram-3"></i> Link Types</h6>
            <div class="form-check">
                <input class="form-check-input" type="checkbox" id="tracerouteLinksCheckbox" checked>
                <label class="form-check-label" for="tracerouteLinksCheckbox">Traceroute Links</label>
            </div>
            <div class="form-check mt-1">
                <input class="form-check-input" type="checkbox" id="packetLinksCheckbox" checked>
                <label class="form-check-label" for="packetLinksCheckbox">Packet Links</label>
            </div>
        </div>

        <!-- Hop depth selector (shown only when a node is selected) -->
        <div class="sidebar-section" id="hopDepthSection" style="display: none;">
            <h6><i class="bi bi-stack"></i> Hop Depth</h6>
            <div class="small text-muted mb-2">Choose how many RF hops from the selected node remain visible.</div>
            <select class="form-select form-select-sm" id="hopDepthSelect">
                <option value="1" selected>1 hop</option>
                <option value="2">2 hops</option>
                <option value="3">3 hops</option>
                <option value="4">4 hops</option>
                <option value="5">5 hops</option>
                <option value="999">All</option>
            </select>
        </div>

        {% set map_legend_items = [
            {"type": "span", "class": "role-color-indicator", "style": "background-color: #007bff;", "content": "", "text": "Client"},
            {"type": "span", "class": "role-color-indicator", "style": "background-color: #28a745;", "content": "", "text": "Router"},
            {"type": "span", "class": "role-color-indicator", "style": "background-color: #28a745;", "content": "", "text": "Router Late"},
            {"type": "span", "class": "role-color-indicator", "style": "background-color: #ffc107;", "content": "", "text": "Repeater"},
            {"type": "span", "class": "role-color-indicator", "style": "background-color: #6c757d;", "content": "", "text": "Client Mute"},
            {"type": "span", "class": "role-color-indicator", "style": "background-color: #17a2b8;", "content": "", "text": "Router Client"},
            {"type": "span", "class": "role-color-indicator", "style": "background-color: #e83e8c;", "content": "", "text": "Sensor"},
            {"type": "span", "class": "role-color-indicator", "style": "background-color: #dc3545;", "content": "", "text": "Unknown Role"},
            {"type": "span", "class": "signal-indicator bg-success", "content": "", "text": "Excellent coverage"},
            {"type": "span", "class": "signal-indicator bg-warning", "content": "", "text": "Good coverage"},
            {"type": "span", "class": "signal-indicator bg-danger", "content": "", "text": "Limited coverage"},
            {"type": "span", "class": "legend-line", "style": "border-top: 4px solid #0d6efd;", "content": "", "text": "Traceroute link"},
            {"type": "span", "class": "legend-line", "style": "border-top: 4px dashed #0d6efd;", "content": "", "text": "Packet link"}
        ] %}
        {% call legend_section(map_legend_items) %}
            <div class="legend-item mt-2">
                <small class="text-muted">Node colors indicate role types<br>
                Click nodes for details<br>
                RF links show radio connections<br>
                Clusters group nearby nodes</small>
            </div>
        {% endcall %}
    {% endcall %}
</div>

<!-- Hide the footer for this page -->
<style>
.footer {
    display: none !important;
}

/* Enhanced animations for packet transmission/reception */
@keyframes pulseGreen {
    0% {
        box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.9);
        transform: scale(1);
    }
    50% {
        box-shadow: 0 0 30px 15px rgba(76, 175, 80, 0.6);
        transform: scale(1.15);
    }
    100% {
        box-shadow: 0 0 60px 30px rgba(76, 175, 80, 0);
        transform: scale(1);
    }
}

@keyframes pulseRed {
    0% {
        box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.9);
        transform: scale(1);
    }
    50% {
        box-shadow: 0 0 30px 15px rgba(244, 67, 54, 0.6);
        transform: scale(1.15);
    }
    100% {
        box-shadow: 0 0 60px 30px rgba(244, 67, 54, 0);
        transform: scale(1);
    }
}

@keyframes rippleGreen {
    0% {
        box-shadow: 0 0 0 0 rgba(76, 175, 80, 1),
                    0 0 0 0 rgba(76, 175, 80, 0.7),
                    0 0 0 0 rgba(76, 175, 80, 0.5);
    }
    100% {
        box-shadow: 0 0 0 20px rgba(76, 175, 80, 0),
                    0 0 0 40px rgba(76, 175, 80, 0),
                    0 0 0 60px rgba(76, 175, 80, 0);
    }
}

@keyframes rippleRed {
    0% {
        box-shadow: 0 0 0 0 rgba(244, 67, 54, 1),
                    0 0 0 0 rgba(244, 67, 54, 0.7),
                    0 0 0 0 rgba(244, 67, 54, 0.5);
    }
    100% {
        box-shadow: 0 0 0 20px rgba(244, 67, 54, 0),
                    0 0 0 40px rgba(244, 67, 54, 0),
                    0 0 0 60px rgba(244, 67, 54, 0);
    }
}

/* Classes for animated markers */
.transmitting-marker {
    animation: pulseGreen 1.2s ease-out !important;
    z-index: 10000 !important;
    position: relative !important;
}

.receiving-marker {
    animation: pulseRed 1.2s ease-out !important;
    z-index: 10000 !important;
    position: relative !important;
}

.transmitting-cluster {
    animation: rippleGreen 1.2s ease-out !important;
    z-index: 10000 !important;
    position: relative !important;
}

.receiving-cluster {
    animation: rippleRed 1.2s ease-out !important;
    z-index: 10000 !important;
    position: relative !important;
}

.map-container {
    position: fixed;
    top: 56px; /* Height of navbar */
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    background: #f8f9fa;
    z-index: 1;
}

/* Dark mode map container */
[data-bs-theme=dark] .map-container {
    background: var(--bs-body-bg);
}

.map-main {
    flex: 1;
    position: relative;
    overflow: hidden;
    order: 1;
}

.network-map {
    width: 100%;
    height: 100%;
}

.loading-overlay, .error-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(248, 249, 250, 0.9);
    z-index: 100;
}

/* Dark mode loading and error overlays */
[data-bs-theme=dark] .loading-overlay {
    background: rgba(13, 17, 23, 0.9);
    color: var(--bs-body-color);
}

[data-bs-theme=dark] .error-overlay {
    background: rgba(13, 17, 23, 0.9);
    color: var(--bs-danger);
}

.error-overlay {
    color: #dc3545;
}

.node-list-container {
    max-height: 400px;
    overflow-y: auto;
}

.node-list {
    max-height: 300px;
    overflow-y: auto;
}

.node-list-item {
    border: 1px solid #dee2e6;
    border-radius: 0.375rem;
    padding: 0.5rem;
    margin-bottom: 0.25rem;
    cursor: pointer;
    transition: background-color 0.2s;
    font-size: 0.875rem;
}

.node-list-item:hover {
    background-color: #f8f9fa;
}

.node-list-item.selected {
    background-color: #e7f3ff;
    border-color: #0d6efd;
}

/* Dark mode node list items */
[data-bs-theme=dark] .node-list-item {
    border: 1px solid var(--bs-border-color);
    color: var(--bs-body-color);
}

[data-bs-theme=dark] .node-list-item:hover {
    background-color: var(--bs-secondary-bg);
}

[data-bs-theme=dark] .node-list-item.selected {
    background-color: rgba(var(--bs-primary-rgb), 0.2);
    border-color: var(--bs-primary);
}

.signal-indicator {
    display: inline-block;
    width: 12px;
    height: 12px;
    border-radius: 50%;
}

.role-color-indicator {
    display: inline-block;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 1px solid white;
    box-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

.age-indicator {
    font-size: 0.75rem;
    padding: 0.1rem 0.3rem;
    border-radius: 0.25rem;
    display: inline-block;
}

.age-fresh { background-color: #d1e7dd; color: #0f5132; }
.age-recent { background-color: #fff3cd; color: #664d03; }
.age-old { background-color: #f8d7da; color: #721c24; }

/* Dark mode age indicators */
[data-bs-theme=dark] .age-fresh {
    background-color: rgba(63, 185, 80, 0.2);
    color: #3fb950;
}

[data-bs-theme=dark] .age-recent {
    background-color: rgba(210, 153, 34, 0.2);
    color: #d29922;
}

[data-bs-theme=dark] .age-old {
    background-color: rgba(248, 81, 73, 0.2);
    color: #f85149;
}

.traceroute-link-info {
    font-size: 0.9rem;
    min-width: 250px;
}

.traceroute-link-info .fw-bold {
    color: #0d6efd;
    border-bottom: 1px solid #dee2e6;
    padding-bottom: 0.25rem;
    margin-bottom: 0.5rem;
}

/* Dark mode traceroute link info */
[data-bs-theme=dark] .traceroute-link-info {
    color: var(--bs-body-color);
}

[data-bs-theme=dark] .traceroute-link-info .fw-bold {
    color: var(--bs-primary);
    border-bottom: 1px solid var(--bs-border-color);
}

/* Custom marker cluster styles */
.marker-cluster-small {
    background-color: rgba(181, 226, 140, 0.6);
}
.marker-cluster-small div {
    background-color: rgba(110, 204, 57, 0.6);
}

.marker-cluster-medium {
    background-color: rgba(241, 211, 87, 0.6);
}
.marker-cluster-medium div {
    background-color: rgba(240, 194, 12, 0.6);
}

.marker-cluster-large {
    background-color: rgba(253, 156, 115, 0.6);
}
.marker-cluster-large div {
    background-color: rgba(241, 128, 23, 0.6);
}

/* Dark mode marker cluster styles */
[data-bs-theme=dark] .marker-cluster-small {
    background-color: rgba(47, 129, 247, 0.6);
}
[data-bs-theme=dark] .marker-cluster-small div {
    background-color: rgba(47, 129, 247, 0.8);
    color: #fff;
}

[data-bs-theme=dark] .marker-cluster-medium {
    background-color: rgba(88, 166, 255, 0.6);
}
[data-bs-theme=dark] .marker-cluster-medium div {
    background-color: rgba(88, 166, 255, 0.8);
    color: #fff;
}

[data-bs-theme=dark] .marker-cluster-large {
    background-color: rgba(248, 81, 73, 0.6);
}
[data-bs-theme=dark] .marker-cluster-large div {
    background-color: rgba(248, 81, 73, 0.8);
    color: #fff;
}

/* Custom node marker styles */
.custom-node-marker {
    background: transparent !important;
    border: none !important;
}

.node-marker-container {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    font-size: 8px;
    font-weight: bold;
    color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    cursor: pointer;
    transition: transform 0.2s ease;
}

/* Dark mode node marker container */
[data-bs-theme=dark] .node-marker-container {
    border: 2px solid var(--bs-body-bg);
    box-shadow: 0 2px 4px rgba(0,0,0,0.5);
}

.node-marker-container:hover {
    transform: scale(1.1);
}

.node-marker-label {
    font-size: 10px;
    line-height: 1;
    max-width: 36px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    text-align: center;
}

/* Additional mobile adjustments specific to map */
@media (max-width: 768px) {
    .map-container {
        flex-direction: column;
        top: 56px;
    }

    .map-main {
        order: 1;
        flex: 1;
    }

    /* Keep nested scroll only for node list and reduce its height for better usability */
    .node-list-container {
        max-height: 40vh; /* Smaller scrollable area */
        overflow-y: auto;
    }

    .node-list {
        max-height: 30vh; /* Nested list scroll area */
        overflow-y: auto;
    }
}

/* Legend line style */
.legend-line {
    display: inline-block;
    width: 22px;
    height: 0;
    margin-right: 4px;
    vertical-align: middle;
}
</style>

{{ sidebar_styles() }}

{% endblock %}

{% block extra_js %}
<!-- Leaflet JS -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- Leaflet MarkerCluster JS -->
<script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>

<script>
let map;
let nodeMarkers = [];
let markerClusterGroup;
let tracerouteLinks = [];
let packetLinks = [];
let nodeData = [];
let tracerouteLinkData = [];
let packetLinkData = [];
let allNodeData = [];
let allTracerouteLinks = [];
let allPacketLinks = [];
let selectedNodeId = null;
let showTracerouteLinks = true;
let showPacketLinks = true;
let precisionCircle = null;
let searchResults = [];
let allNodes = [];
let linkData = [];
let firstDisplay = true; // prevent recenter after initial load
let currentHopDepth = 1; // max hop depth to display around selected node

// Mapping of node_id to its Leaflet marker for quick lookup during live packet
// animations.  This object will be populated in addNodeMarker() when markers
// are created.  Using this map avoids scanning all markers to find a node
// when a live packet arrives.
let nodeMarkerMap = {};

// Define a maximum realistic RF link distance (in kilometers).  Links
// exceeding this threshold will be ignored when rendering UNLESS they have
// valid SNR/RSSI values indicating a real RF connection. Meshtastic
// devices are not expected to maintain links over extreme distances such
// as 1000km; filtering out long links avoids misleading visuals when
// packets traverse via MQTT or misconfigured nodes.
const MAX_LINK_DISTANCE_KM = 150;

// Initialize the page
document.addEventListener('DOMContentLoaded', function() {
    // Wait for jQuery to be available
    function waitForJQuery() {
        if (typeof $ !== 'undefined') {
            initializeInterface();
            initMap();
            // After the map has been initialized, establish a live packet stream.
            // This stream will trigger node or cluster flashing when packets
            // are broadcast or received in real time.
            connectLiveStream();
        } else {
            setTimeout(waitForJQuery, 50);
        }
    }

    waitForJQuery();
});

function initializeInterface() {
    // Handle sidebar toggle
    $('#toggleSidebar').on('click', function() {
        const sidebar = document.getElementById('sidebar');
        const icon = this.querySelector('i');
        const isMobile = window.innerWidth <= 768;

        sidebar.classList.toggle('collapsed');

        if (sidebar.classList.contains('collapsed')) {
            if (isMobile) {
                icon.className = 'bi bi-chevron-up';
            } else {
                icon.className = 'bi bi-chevron-left';
            }
        } else {
            if (isMobile) {
                icon.className = 'bi bi-chevron-down';
            } else {
                icon.className = 'bi bi-chevron-right';
            }
        }

        // Trigger map resize after animation
        setTimeout(() => {
            if (map) {
                map.invalidateSize();
                fitMapToNodes();
            }
        }, 300);
    });

    // Handle window resize to update toggle button icon
    $(window).on('resize', function() {
        const sidebar = document.getElementById('sidebar');
        const icon = document.querySelector('#toggleSidebar i');
        const isMobile = window.innerWidth <= 768;

        if (sidebar && icon) {
            if (sidebar.classList.contains('collapsed')) {
                icon.className = isMobile ? 'bi bi-chevron-up' : 'bi bi-chevron-left';
            } else {
                icon.className = isMobile ? 'bi bi-chevron-down' : 'bi bi-chevron-right';
            }
        }
    });

    // Set initial icon orientation on page load
    const sidebar = document.getElementById('sidebar');
    const initialIcon = document.querySelector('#toggleSidebar i');
    const isMobileInitial = window.innerWidth <= 768;
    if (sidebar && initialIcon) {
        if (sidebar.classList.contains('collapsed')) {
            initialIcon.className = isMobileInitial ? 'bi bi-chevron-up' : 'bi bi-chevron-left';
        } else {
            initialIcon.className = isMobileInitial ? 'bi bi-chevron-down' : 'bi bi-chevron-right';
        }
    }

    // Handle clear selection button
    $('#clearSelection').on('click', function() {
        clearNodeSelection();
    });

    // Handle node search with unified list
    $('#nodeSearch').on('input', function() {
        const query = this.value.toLowerCase().trim();
        if (query.length > 0) {
            searchNodes(query);
        } else {
            showAllNodes();
        }
    });

    $('#clearSearch').on('click', function() {
        $('#nodeSearch').val('');
        showAllNodes();
        clearNodeSelection();
    });

    // Handle filter form submission
    $('#locationFilterForm').on('submit', function(e) {
        e.preventDefault();
        applyClientSideFilters();
    });

    // Link type checkbox handlers
    $('#tracerouteLinksCheckbox').on('change', function() {
        const desiredState = this.checked;
        if (desiredState !== showTracerouteLinks) {
            toggleTracerouteLinks();
        }
    });

    $('#packetLinksCheckbox').on('change', function() {
        const desiredState = this.checked;
        if (desiredState !== showPacketLinks) {
            togglePacketLinks();
        }
    });

    // Hop depth selector change handler
    $('#hopDepthSelect').on('change', function() {
        currentHopDepth = parseInt(this.value, 10);
        if (selectedNodeId !== null) {
            drawHopNetwork();
        }
    });

    // Sync MaxAge select with date-time pickers
    function toLocalInputValue(dateObj) {
        const pad = (n)=> n.toString().padStart(2,'0');
        return `${dateObj.getFullYear()}-${pad(dateObj.getMonth()+1)}-${pad(dateObj.getDate())}T${pad(dateObj.getHours())}:${pad(dateObj.getMinutes())}`;
    }

    $('#maxAge').on('change', function() {
        const val = this.value;
        if (!val) {
            // No Limit selected – clear date inputs
            $('#startDateTime').val('');
            $('#endDateTime').val('');
        } else {
            const hours = parseInt(val,10);
            if (!isNaN(hours)) {
                const end = new Date();
                const start = new Date(end.getTime() - hours*3600*1000);
                $('#startDateTime').val(toLocalInputValue(start));
                $('#endDateTime').val(toLocalInputValue(end));
            }
        }
        applyClientSideFilters();
    });

    // Clear dates button
    $('#clearDateRange').on('click', function() {
        $('#startDateTime').val('');
        $('#endDateTime').val('');
        $('#maxAge').val('');
        applyClientSideFilters();
    });

    // Move hop depth section just below the selected details container
    $('#hopDepthSection').insertAfter($('#selectedDetails'));

    // --------------------------------------------------------------
    // Dynamic loading of primary channels for filter dropdown
    // --------------------------------------------------------------
    async function loadPrimaryChannels() {
        try {
            const response = await fetch('/api/meshtastic/channels');
            const data = await response.json();
            if (data.channels) {
                const select = document.getElementById('channelFilter');
                const allOption = select.querySelector('option[value=""]');
                select.innerHTML = '';
                select.appendChild(allOption);
                data.channels.forEach((ch) => {
                    const option = document.createElement('option');
                    option.value = ch;
                    option.textContent = ch;
                    select.appendChild(option);
                });
            }
        } catch (error) {
            console.error('Error loading primary channels:', error);
        }
    }

    // Load channels on interface init
    loadPrimaryChannels();
}

// Initialize the map
function initMap() {
    // Create map centered on a default location (will be updated when data loads)
    map = L.map('map').setView([40.0, -95.0], 4);

    // Add Carto Dark Matter tiles for dark mode
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
        attribution: '© <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors © <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
    }).addTo(map);

    // Initialize marker cluster group
    markerClusterGroup = L.markerClusterGroup({
        maxClusterRadius: 50, // Cluster markers within 50 pixels
        spiderfyOnMaxZoom: true,
        showCoverageOnHover: true,
        zoomToBoundsOnClick: true,
        iconCreateFunction: function(cluster) {
            const childCount = cluster.getChildCount();
            let className = 'marker-cluster-small';
            if (childCount > 10) {
                className = 'marker-cluster-large';
            } else if (childCount > 5) {
                className = 'marker-cluster-medium';
            }

            return new L.DivIcon({
                html: '<div><span>' + childCount + '</span></div>',
                className: 'marker-cluster ' + className,
                iconSize: new L.Point(40, 40)
            });
        }
    });
    map.addLayer(markerClusterGroup);

    // Load node data
    loadNodeLocations();
}

// Build filter parameters from form
function buildFilterParams() {
    const form = document.getElementById('locationFilterForm');
    const formData = new FormData(form);
    const params = new URLSearchParams();

    // Only send server-side filters (gateway, search, etc.)
    // Age and role filtering is now done client-side

    return params;
}

// Load node locations from API
async function loadNodeLocations() {
    try {
        showLoading();

        const params = buildFilterParams();
        const response = await fetch(`/api/locations?${params.toString()}`);
        const data = await response.json();

        if (data.error) {
            showError(data.error);
            return;
        }

        // Store all data for client-side filtering
        allNodeData = data.locations || [];

        // Combine traceroute and packet links but tag with type for filtering
        const tracerouteLinksFetched = (data.traceroute_links || []).map(l => ({ ...l, link_type: 'traceroute' }));
        const packetLinksFetched = (data.packet_links || []).map(l => ({ ...l, link_type: 'packet' }));

        allLinkData = [...tracerouteLinksFetched, ...packetLinksFetched];

        // Apply client-side filters
        applyClientSideFilters();

        hideLoading();

    } catch (error) {
        console.error('Error loading node locations:', error);
        showError('Failed to load node locations');
    }
}

// Apply client-side filters to the data
function applyClientSideFilters() {
    const form = document.getElementById('locationFilterForm');
    const formData = new FormData(form);

    // Get filter values
    const maxAge = formData.get('maxAge'); // still read to sync UI but no longer used for filtering
    const roleFilter = formData.get('roleFilter');
    const channelFilter = formData.get('channelFilter');
    const startDateTime = formData.get('startDateTime');
    const endDateTime = formData.get('endDateTime');
    const minContacts = formData.get('minContacts');

    // Start with all data
    let filteredNodes = [...allNodeData];
    let filteredLinks = [...allLinkData];

    const currentTime = Date.now() / 1000;

    // Apply role filter
    if (roleFilter) {
        if (roleFilter === 'UNKNOWN') {
            // Filter for nodes with null, undefined, or unknown roles
            filteredNodes = filteredNodes.filter(node =>
                !node.role || node.role === 'UNKNOWN' || node.role === 'Unknown'
            );
        } else {
            filteredNodes = filteredNodes.filter(node => node.role === roleFilter);
        }
    }

    // Apply channel filter
    if (channelFilter) {
        filteredNodes = filteredNodes.filter(node => node.primary_channel === channelFilter);
    }

    // Convert date inputs to timestamps for comparison
    let startTimestamp = null;
    let endTimestamp = null;
    if (startDateTime) {
        startTimestamp = new Date(startDateTime).getTime() / 1000;
        filteredNodes = filteredNodes.filter(node => node.timestamp >= startTimestamp);
    }

    if (endDateTime) {
        endTimestamp = new Date(endDateTime).getTime() / 1000;
        filteredNodes = filteredNodes.filter(node => node.timestamp <= endTimestamp);
    }

    // Filter links by minimum number of direct contacts (total_hops_seen)
    const minContactsNum = parseInt(minContacts || '1', 10);
    if (!isNaN(minContactsNum) && minContactsNum > 1) {
        filteredLinks = filteredLinks.filter(link => {
            if (link.total_hops_seen !== undefined && link.total_hops_seen !== null) {
                return link.total_hops_seen >= minContactsNum;
            }
            // If metric not available, exclude link when threshold >1
            return false;
        });
    }

    // Filter links to only include those between visible nodes
    const visibleNodeIds = new Set(filteredNodes.map(node => node.node_id));
    filteredLinks = filteredLinks.filter(link =>
        visibleNodeIds.has(link.from_node_id) && visibleNodeIds.has(link.to_node_id)
    );

    // Apply date filters to links based on last_seen if available
    if (startTimestamp !== null || endTimestamp !== null) {
        filteredLinks = filteredLinks.filter(link => {
            if (!link.last_seen_str) return true;
            const linkTs = Date.parse(link.last_seen_str) / 1000;
            if (startTimestamp !== null && linkTs < startTimestamp) return false;
            if (endTimestamp !== null && linkTs > endTimestamp) return false;
            return true;
        });
    }

    // Update global variables
    nodeData = filteredNodes;
    tracerouteLinkData = filteredLinks.filter(link => link.link_type === 'traceroute');
    packetLinkData = filteredLinks.filter(link => link.link_type === 'packet');
    allNodes = nodeData; // Set the unified node list

    // Update the map display
    updateMapDisplay();
}

// Update map display with filtered data
function updateMapDisplay() {
    // Update statistics
    updateStats();

    // Clear existing markers
    markerClusterGroup.clearLayers();
    nodeMarkers = [];
    // Reset the marker lookup since we're rebuilding markers from scratch.
    nodeMarkerMap = {};

    // Add markers for each filtered node
    nodeData.forEach(node => {
        addNodeMarker(node);
    });

    // Update unified node list
    showAllNodes();

    // Load links if at least one type is enabled
    if (showTracerouteLinks && tracerouteLinkData.length > 0) {
        drawTracerouteLinks();
    }

    if (showPacketLinks && packetLinkData.length > 0) {
        drawPacketLinks();
    }

    // Fit map only on first render
    if (firstDisplay && nodeMarkers.length > 0) {
        setTimeout(() => {
            fitMapToNodes();
        }, 500);
        firstDisplay = false;
    }
}

// Add a marker for a node
function addNodeMarker(node) {
    // Create custom marker with role-based styling
    const roleColor = getRoleColor(node.role);

    // Determine display text for the marker
    let displayText = node.short_name || node.display_name;

    // Handle the case where display_name is "Node {hex_id}" format
    if (!displayText || displayText.trim() === '' || displayText.startsWith('Node ')) {
        const nodeIdHex = node.node_id.toString(16).padStart(8, '0');
        displayText = nodeIdHex.slice(-4).toUpperCase();
    } else if (displayText.length > 4) {
        displayText = displayText.substring(0, 4);
    }

    const markerIcon = L.divIcon({
        className: 'custom-node-marker',
        html: `
            <div class="node-marker-container" style="background-color: ${roleColor};">
                <div class="node-marker-label">${displayText}</div>
            </div>
        `,
        iconSize: [40, 40],
        iconAnchor: [20, 20]
    });

    const marker = L.marker([node.latitude, node.longitude], { icon: markerIcon });

    // Create popup content
    const popupContent = createNodePopupContent(node);
    marker.bindPopup(popupContent);

    // Add click handler
    marker.on('click', function() {
        selectNode(node);
    });

    markerClusterGroup.addLayer(marker);
    nodeMarkers.push(marker);

    // Also store a lookup from node_id to its marker.  This is used by live packet
    // animations to quickly find the marker corresponding to a packet's source or
    // destination.  Without this mapping, the animation would have to scan all
    // markers on each event.  Note: node.node_id is a numeric identifier.
    nodeMarkerMap[node.node_id] = marker;
}

// Create popup content for a node
function createNodePopupContent(node) {
    const nodeIdHex = node.node_id.toString(16).padStart(8, '0');
    const ageHours = (Date.now() / 1000 - node.timestamp) / 3600;
    const ageClass = getAgeClass(ageHours);
    const roleColor = getRoleColor(node.role);

    return `
        <div class="node-marker-info">
            <div class="node-marker-title">${node.display_name}</div>
            <div><strong>ID:</strong> !${nodeIdHex}</div>
            ${node.short_name ? `<div><strong>Short Name:</strong> ${node.short_name}</div>` : ''}
            ${node.role ? `<div><strong>Role:</strong> <span class="badge" style="background-color: ${roleColor};">${node.role}</span></div>` : ''}
            <div><strong>Location:</strong> ${node.latitude.toFixed(6)}, ${node.longitude.toFixed(6)}</div>
            ${node.altitude ? `<div><strong>Altitude:</strong> ${node.altitude}m</div>` : ''}
            ${node.hw_model ? `<div><strong>Hardware:</strong> ${node.hw_model}</div>` : ''}
            <div><strong>Age:</strong> <span class="age-indicator ${ageClass}">${formatAge(ageHours)}</span></div>

            <div class="mt-2">
                <button class="btn btn-sm btn-primary" onclick="viewNodeDetails(${node.node_id})">
                    View Details
                </button>
            </div>
        </div>
    `;
}

// Unified node search and display
function searchNodes(query) {
    if (!allNodes || allNodes.length === 0) {
        return;
    }

    const results = allNodes.filter(node => {
        const nodeIdHex = node.node_id.toString(16).padStart(8, '0');
        return node.display_name.toLowerCase().includes(query) ||
               nodeIdHex.includes(query) ||
               node.node_id.toString().includes(query) ||
               (node.hw_model && node.hw_model.toLowerCase().includes(query));
    }).slice(0, 20); // Limit to 20 results

    searchResults = results;
    displayNodeList(results, true);

    // Update search count
    document.getElementById('searchResultsCount').style.display = 'block';
    document.getElementById('searchCount').textContent = results.length;
}

// Show all nodes (when not searching)
function showAllNodes() {
    searchResults = [];
    displayNodeList(allNodes, false);

    // Hide search count
    document.getElementById('searchResultsCount').style.display = 'none';
}

// Display node list (unified for search results and full list)
function displayNodeList(nodes, isSearchResults = false) {
    const container = document.getElementById('nodeList');
    const nodeCount = document.getElementById('nodeCount');

    if (!isSearchResults) {
        nodeCount.textContent = nodes.length;
    }

    if (nodes.length === 0) {
        const message = isSearchResults ? 'No nodes found' : 'No nodes available';
        container.innerHTML = `<div class="text-center text-muted py-4"><small>${message}</small></div>`;
        return;
    }

    // Sort nodes by name
    const sortedNodes = [...nodes].sort((a, b) => a.display_name.localeCompare(b.display_name));

    container.innerHTML = sortedNodes.map(node => {
        const nodeIdHex = node.node_id.toString(16).padStart(8, '0');
        const ageHours = (Date.now() / 1000 - node.timestamp) / 3600;
        const ageClass = getAgeClass(ageHours);
        const roleColor = getRoleColor(node.role);

        return `
            <div class="node-list-item" onclick="selectNodeFromList(${node.node_id})">
                <div><strong>${node.display_name}</strong> ${node.role ? `<span class="badge badge-sm" style="background-color: ${roleColor}; font-size: 0.6em;">${formatRole(node.role)}</span>` : ''}</div>
                <small class="text-muted">!${nodeIdHex}</small><br>
                <span class="age-indicator ${ageClass}">${formatAge(ageHours)}</span>
                ${node.hw_model ? `<small class="text-secondary ms-2">${node.hw_model}</small>` : ''}
            </div>
        `;
    }).join('');

    // Update selection highlighting
    updateNodeListSelection();
}

// Select node from list
function selectNodeFromList(nodeId) {
    const node = allNodes.find(n => n.node_id === nodeId);
    if (node) {
        focusOnNode(node);
        selectNode(node);
    }
}

// Focus on a node on the map
function focusOnNode(node) {
    if (map) {
        map.setView([node.latitude, node.longitude], 15);
    }
}

// Select a node
function selectNode(node) {
    selectedNodeId = node.node_id;

    // Show hop depth controls
    document.getElementById('hopDepthSection').style.display = 'block';

    // Update node list selection
    updateNodeListSelection();

    // Show node details
    showSelectedNodeDetails(node);

    // Apply hop filter & render (skip map fit so we stay centered on the clicked node)
    drawHopNetwork(true);

    // Show precision circle
    showPrecisionCircle(node);
}

// Show selected node details
function showSelectedNodeDetails(node) {
    const nodeIdHex = node.node_id.toString(16).padStart(8, '0');
    const ageHours = (Date.now() / 1000 - node.timestamp) / 3600;
    const ageClass = getAgeClass(ageHours);
    const roleColor = getRoleColor(node.role);

    const content = `
        <div class="row">
            <div class="col-12">
                <h6>${node.display_name}</h6>
                <p class="text-muted">Node ID: !${nodeIdHex}</p>
                ${node.short_name ? `<p class="text-muted">Short: ${node.short_name}</p>` : ''}
            </div>
        </div>
        <div class="row">
            <div class="col-6">
                <strong>Location:</strong><br>
                <small>${node.latitude.toFixed(6)}, ${node.longitude.toFixed(6)}</small>
            </div>
            <div class="col-6">
                <strong>Age:</strong><br>
                <span class="age-indicator ${ageClass}">${formatAge(ageHours)}</span>
            </div>
        </div>
        ${node.role ? `
        <div class="row mt-2">
            <div class="col-6">
                <strong>Role:</strong><br>
                <span class="badge" style="background-color: ${roleColor};">${node.role}</span>
            </div>
            ${node.altitude ? `
            <div class="col-6">
                <strong>Altitude:</strong><br>
                <span class="text-info">${node.altitude}m</span>
            </div>
            ` : ''}
        </div>
        ` : node.altitude ? `
        <div class="row mt-2">
            <div class="col-6">
                <strong>Altitude:</strong><br>
                <span class="text-info">${node.altitude}m</span>
            </div>
        </div>
        ` : ''}
        ${node.hw_model ? `
        <div class="row mt-2">
            <div class="col-12">
                <strong>Hardware:</strong><br>
                <span class="text-secondary">${node.hw_model}</span>
            </div>
        </div>
        ` : ''}
        <div class="row mt-2">
            <div class="col-12">
                <a href="/node/${node.node_id}" class="btn btn-primary btn-sm">
                    <i class="bi bi-router"></i> View Node Details
                </a>
            </div>
        </div>
    `;

    document.getElementById('selectedDetailsContent').innerHTML = content;
    document.getElementById('selectedDetails').style.display = 'block';
}

// Clear node selection
function clearNodeSelection() {
    selectedNodeId = null;

    // Hide hop depth controls
    document.getElementById('hopDepthSection').style.display = 'none';
    currentHopDepth = 1;
    document.getElementById('hopDepthSelect').value = '1';

    // Clear search result highlights
    document.querySelectorAll('.search-result-item').forEach(item => {
        item.classList.remove('selected');
    });

    // Clear node list selection
    updateNodeListSelection();

    // Hide selected details
    document.getElementById('selectedDetails').style.display = 'none';

    // Hide precision circle
    if (precisionCircle) {
        map.removeLayer(precisionCircle);
        precisionCircle = null;
    }

    // Restore full map display
    updateMapDisplay();
}

// Clear search results
function clearSearchResults() {
    document.getElementById('searchResults').innerHTML = '';
    searchResults = [];
}

// Update node list
function updateNodeList() {
    const container = document.getElementById('nodeList');
    const nodeCount = document.getElementById('nodeCount');

    nodeCount.textContent = nodeData.length;

    if (nodeData.length === 0) {
        container.innerHTML = '<div class="text-center text-muted py-4"><small>No nodes found</small></div>';
        return;
    }

    // Sort nodes by name
    const sortedNodes = [...nodeData].sort((a, b) => a.display_name.localeCompare(b.display_name));

    container.innerHTML = sortedNodes.map(node => {
        const nodeIdHex = node.node_id.toString(16).padStart(8, '0');
        const ageHours = (Date.now() / 1000 - node.timestamp) / 3600;
        const ageClass = getAgeClass(ageHours);
        const roleColor = getRoleColor(node.role);

        return `
            <div class="node-list-item" onclick="selectNodeFromList(${node.node_id})">
                <div><strong>${node.display_name}</strong> ${node.role ? `<span class="badge badge-sm" style="background-color: ${roleColor}; font-size: 0.6em;">${formatRole(node.role)}</span>` : ''}</div>
                <small class="text-muted">!${nodeIdHex}</small><br>
                <span class="age-indicator ${ageClass}">${formatAge(ageHours)}</span>
                ${node.hw_model ? `<small class="text-secondary ms-2">${node.hw_model}</small>` : ''}
            </div>
        `;
    }).join('');
}

// Select node from list
function selectNodeFromList(nodeId) {
    const node = nodeData.find(n => n.node_id === nodeId);
    if (node) {
        focusOnNode(node);
        selectNode(node);
    }
}

// Update node list selection
function updateNodeListSelection() {
    document.querySelectorAll('.node-list-item').forEach(item => {
        const nodeId = parseInt(item.getAttribute('onclick').match(/\d+/)[0]);
        item.classList.toggle('selected', nodeId === selectedNodeId);
    });
}

// Update statistics
function updateStats() {
    document.getElementById('statsNodes').textContent = nodeData.length;
    document.getElementById('statsWithLocation').textContent = nodeData.length;
    document.getElementById('statsLinks').textContent = tracerouteLinkData.length + packetLinkData.length;
    document.getElementById('statsLastUpdate').textContent = new Date().toLocaleTimeString();
}

// Show precision circle
function showPrecisionCircle(node) {
    // Remove existing circle
    if (precisionCircle) {
        map.removeLayer(precisionCircle);
    }

    // Use real GPS precision if available, otherwise fall back to age-based estimation
    let radiusMeters = 10; // Default precision
    let precisionSource = 'estimated';

    if (node.precision_meters && node.precision_meters > 0) {
        // Use actual GPS precision from the position packet
        radiusMeters = node.precision_meters;
        precisionSource = 'GPS reported';
    } else {
        // Fall back to age-based estimation
        const ageHours = (Date.now() / 1000 - node.timestamp) / 3600;
        if (ageHours > 168) { // > 1 week
            radiusMeters = 500; // Very imprecise for very old data
        } else if (ageHours > 24) { // > 1 day
            radiusMeters = 100; // Less precise for old data
        } else if (ageHours > 6) { // > 6 hours
            radiusMeters = 30; // Medium precision
        } else if (ageHours > 1) { // > 1 hour
            radiusMeters = 15; // Good precision
        }
        precisionSource = 'age estimated';
    }

    // Create circle
    precisionCircle = L.circle([node.latitude, node.longitude], {
        color: '#007bff',
        fillColor: '#007bff',
        fillOpacity: 0.1,
        radius: radiusMeters
    }).addTo(map);

    // No tooltip for precision circles per user request
}

// Helper functions
function getAgeClass(ageHours) {
    if (ageHours < 1) return 'age-fresh';
    if (ageHours < 24) return 'age-recent';
    return 'age-old';
}

function formatAge(ageHours) {
    if (isNaN(ageHours) || ageHours < 0) {
        return 'Unknown';
    }
    if (ageHours < 1) {
        return `${Math.round(ageHours * 60)}m ago`;
    } else if (ageHours < 24) {
        return `${Math.round(ageHours)}h ago`;
    } else {
        return `${Math.round(ageHours / 24)}d ago`;
    }
}

function getRoleColor(role) {
    switch (role) {
        case 'CLIENT': return '#007bff'; // Blue
        case 'CLIENT_MUTE': return '#6c757d'; // Gray
        case 'ROUTER': return '#28a745'; // Green
        case 'ROUTER_LATE': return '#28a745'; // Green (same as ROUTER)
        case 'REPEATER': return '#ffc107'; // Yellow
        case 'ROUTER_CLIENT': return '#17a2b8'; // Teal
        case 'SENSOR': return '#e83e8c'; // Pink
        default: return '#dc3545'; // Red for unknown/null roles
    }
}

function formatRole(role) {
    if (!role || role === 'Unknown') return '?';
    switch (role) {
        case 'CLIENT': return 'C';
        case 'CLIENT_MUTE': return 'CM';
        case 'ROUTER': return 'R';
        case 'ROUTER_LATE': return 'RL';
        case 'REPEATER': return 'RP';
        case 'ROUTER_CLIENT': return 'RC';
        case 'SENSOR': return 'S';
        default: return '?';
    }
}

// Map control functions
function fitMapToNodes() {
    if (nodeMarkers.length === 0) {
        return;
    }

    // Collect lat/lngs from markers
    const latLngs = nodeMarkers.map(m => m.getLatLng());

    // If we have enough markers, trim extreme outliers (top / bottom 2.5%)
    let bounds;
    if (latLngs.length > 4) {
        const lats = latLngs.map(ll => ll.lat).sort((a, b) => a - b);
        const lngs = latLngs.map(ll => ll.lng).sort((a, b) => a - b);

        const lowerIdx = Math.floor(lats.length * 0.025);
        const upperIdx = Math.ceil(lats.length * 0.975) - 1;

        const minLat = lats[lowerIdx];
        const maxLat = lats[upperIdx];
        const minLng = lngs[lowerIdx];
        const maxLng = lngs[upperIdx];

        bounds = L.latLngBounds([[minLat, minLng], [maxLat, maxLng]]);
    } else {
        bounds = L.latLngBounds(latLngs);
    }

    // Determine extra bottom padding on mobile when the sidebar is expanded
    let paddingTopLeft = [20, 20];
    let paddingBottomRight = [20, 20];

    if (window.innerWidth <= 768) {
        const sidebar = document.getElementById('sidebar');
        if (sidebar) {
            // Collapsed sidebar shows only a ~60px header, otherwise full 60vh
            const sidebarHeight = sidebar.classList.contains('collapsed') ? 60 : sidebar.clientHeight || window.innerHeight * 0.6;
            paddingBottomRight = [20, 20 + sidebarHeight];
        }
    }

    map.fitBounds(bounds, {
        paddingTopLeft: paddingTopLeft,
        paddingBottomRight: paddingBottomRight,
    });
}

function toggleTracerouteLinks() {
    showTracerouteLinks = !showTracerouteLinks;

    // Clear existing traceroute polylines
    tracerouteLinks.forEach(link => map.removeLayer(link));
    tracerouteLinks = [];

    if (selectedNodeId !== null) {
        // When a node is selected, just redraw hop network respecting new visibility
        drawHopNetwork();
        return;
    }

    const btn = document.getElementById('linkToggleBtn'); // may be null on this page

    if (showTracerouteLinks) {
        drawTracerouteLinks();
        if (btn) {
            btn.innerHTML = '<i class="bi bi-link-45deg"></i> Hide Traceroute Links';
            btn.className = 'btn btn-sm btn-outline-info';
        }
    } else {
        if (btn) {
            btn.innerHTML = '<i class="bi bi-link-45deg-off"></i> Show Traceroute Links';
            btn.className = 'btn btn-sm btn-outline-secondary';
        }
    }
}

function togglePacketLinks() {
    showPacketLinks = !showPacketLinks;

    // Clear existing packet polylines
    packetLinks.forEach(link => map.removeLayer(link));
    packetLinks = [];

    if (selectedNodeId !== null) {
        drawHopNetwork();
        return;
    }

    const btn = document.getElementById('packetLinkToggleBtn'); // may be null

    if (showPacketLinks) {
        drawPacketLinks();
        if (btn) {
            btn.innerHTML = '<i class="bi bi-envelope-open"></i> Hide Packet Links';
            btn.className = 'btn btn-sm btn-outline-info';
        }
    } else {
        if (btn) {
            btn.innerHTML = '<i class="bi bi-envelope-open"></i> Show Packet Links';
            btn.className = 'btn btn-sm btn-outline-secondary';
        }
    }
}

// Draw traceroute links on the map
function drawTracerouteLinks() {
    drawTracerouteLinksFiltered(null);
}

// Draw traceroute links with optional filtering by node
function drawTracerouteLinksFiltered(filterNodeId = null) {
    // Clear existing traceroute polylines
    tracerouteLinks.forEach(link => map.removeLayer(link));
    tracerouteLinks = [];

    const nodePositions = {};

    // Build node position lookup
    nodeData.forEach(node => {
        nodePositions[node.node_id] = [node.latitude, node.longitude];
    });

    // Start with traceroute link data only
    let linksToShow = tracerouteLinkData;
    if (filterNodeId !== null) {
        linksToShow = linksToShow.filter(link =>
            link.from_node_id === filterNodeId ||
            link.to_node_id === filterNodeId
        );
    }

    linksToShow.forEach(link => {
        const fromPos = nodePositions[link.from_node_id];
        const toPos = nodePositions[link.to_node_id];

        if (!fromPos || !toPos) {
            return; // Skip if either node doesn't have position
        }

        // Determine link color and style based on success rate and SNR
        let linkColor = '#999999';
        let linkWeight = 2;
        let linkOpacity = 0.6;

        // If filtering by node, highlight the selected node's links
        if (filterNodeId !== null) {
            linkWeight = 3; // Make filtered links thicker
            linkOpacity = 0.9; // Make them more opaque
        }

        if (link.success_rate >= 80) {
            linkColor = '#28a745'; // Green for high success
        } else if (link.success_rate >= 50) {
            linkColor = '#ffc107'; // Yellow for medium success
        } else {
            linkColor = '#dc3545'; // Red for low success
        }

        // Create the line
        const line = L.polyline([fromPos, toPos], {
            color: linkColor,
            weight: linkWeight,
            opacity: linkOpacity,
            dashArray: link.success_rate < 50 ? '5, 5' : null // Dashed for unreliable links
        });

        // Add popup with link information
        const popupContent = createLinkPopupContent(link);
        line.bindPopup(popupContent);

        line.addTo(map);
        tracerouteLinks.push(line);
    });
}

// Draw only links connected to a specific node
function drawFilteredTracerouteLinks(nodeId) {
    drawTracerouteLinksFiltered(nodeId);
}

// Draw packet links on the map
function drawPacketLinks() {
    drawPacketLinksFiltered(null);
}

// Draw packet links with optional filtering by node
function drawPacketLinksFiltered(filterNodeId = null) {
    // Clear existing packet polylines
    packetLinks.forEach(link => map.removeLayer(link));
    packetLinks = [];

    const nodePositions = {};

    // Build node position lookup
    nodeData.forEach(node => {
        nodePositions[node.node_id] = [node.latitude, node.longitude];
    });

    // Start with packet link data only
    let linksToShow = packetLinkData;
    if (filterNodeId !== null) {
        linksToShow = linksToShow.filter(link =>
            link.from_node_id === filterNodeId ||
            link.to_node_id === filterNodeId
        );
    }

    linksToShow.forEach(link => {
        const fromPos = nodePositions[link.from_node_id];
        const toPos = nodePositions[link.to_node_id];

        if (!fromPos || !toPos) {
            return; // Skip if either node doesn't have position
        }

        // Determine link color and style based on success rate and SNR
        let linkColor = '#999999';
        let linkWeight = 2;
        let linkOpacity = 0.6;

        // If filtering by node, highlight the selected node's links
        if (filterNodeId !== null) {
            linkWeight = 3; // Make filtered links thicker
            linkOpacity = 0.9; // Make them more opaque
        }

        if (link.success_rate >= 80) {
            linkColor = '#28a745'; // Green for high success
        } else if (link.success_rate >= 50) {
            linkColor = '#ffc107'; // Yellow for medium success
        } else {
            linkColor = '#dc3545'; // Red for low success
        }

        // Packet links get dashed style to visually distinguish
        const isPacket = link.link_type === 'packet';

        const line = L.polyline([fromPos, toPos], {
            color: linkColor,
            weight: linkWeight,
            opacity: linkOpacity,
            dashArray: isPacket ? '3, 6' : (link.success_rate < 50 ? '5, 5' : null)
        });

        // Add popup with link information
        const popupContent = createLinkPopupContent(link);
        line.bindPopup(popupContent);

        line.addTo(map);
        packetLinks.push(line);
    });
}

// Draw only links connected to a specific node
function drawFilteredPacketLinks(nodeId) {
    drawPacketLinksFiltered(nodeId);
}

// Create popup content for traceroute links
function createLinkPopupContent(link) {
    const fromNode = nodeData.find(n => n.node_id === link.from_node_id);
    const toNode = nodeData.find(n => n.node_id === link.to_node_id);

    const fromName = fromNode ? fromNode.display_name : `!${link.from_node_id.toString(16).padStart(8, '0')}`;
    const toName = toNode ? toNode.display_name : `!${link.to_node_id.toString(16).padStart(8, '0')}`;

    let qualityClass = 'text-success';
    if (link.success_rate < 50) qualityClass = 'text-danger';
    else if (link.success_rate < 80) qualityClass = 'text-warning';

    return `
        <div class="traceroute-link-info">
            <div class="fw-bold mb-2">${link.link_type === 'packet' ? 'Direct Packet Link' : 'Traceroute RF Hop'}</div>
            <div><strong>From:</strong> ${fromName}</div>
            <div><strong>To:</strong> ${toName}</div>
            <div><strong>Success Rate:</strong> <span class="${qualityClass}">${link.success_rate.toFixed(1)}%</span></div>
            <div><strong>Attempts:</strong> ${link.total_hops_seen}</div>
            <div><strong>Last Seen:</strong> ${link.last_seen_str}</div>
            ${link.avg_snr ? `<div><strong>Avg SNR:</strong> ${link.avg_snr.toFixed(1)} dB</div>` : ''}
            ${link.avg_rssi ? `<div><strong>Avg RSSI:</strong> ${link.avg_rssi.toFixed(0)} dBm</div>` : ''}
            <div class="mt-2">
                <button class="btn btn-sm btn-primary" onclick="showTracerouteHistory(${link.from_node_id}, ${link.to_node_id})">
                    View History
                </button>
            </div>
        </div>
    `;
}

// Show detailed traceroute history between two nodes
function showTracerouteHistory(fromNodeId, toNodeId) {
    let url;
    if (window.URLFilterManager) {
        const urlManager = new URLFilterManager();
        url = urlManager.createFilteredURL('/traceroute-hops', {
            from_node: fromNodeId,
            to_node: toNodeId
        });
    } else {
        // Fallback if URL filter manager is not available
        url = `/traceroute-hops?from_node=${fromNodeId}&to_node=${toNodeId}`;
    }
    window.open(url, '_blank');
}

// View node details
function viewNodeDetails(nodeId) {
    window.open(`/node/${nodeId}`, '_blank');
}

// Refresh map
function refreshMap() {
    loadNodeLocations();
}

// Loading/error functions
function showLoading() {
    document.getElementById('mapLoading').style.display = 'flex';
    document.getElementById('map').style.opacity = '0.5';
    document.getElementById('mapError').style.display = 'none';
}

function hideLoading() {
    document.getElementById('mapLoading').style.display = 'none';
    document.getElementById('map').style.opacity = '1';
}

function showError(message) {
    document.getElementById('mapLoading').style.display = 'none';
    document.getElementById('map').style.opacity = '0.5';
    const errorDiv = document.getElementById('mapError');
    errorDiv.style.display = 'flex';
    errorDiv.querySelector('p').textContent = message;
}

// Handle window resize
window.addEventListener('resize', function() {
    if (map) {
        setTimeout(() => {
            map.invalidateSize();
            fitMapToNodes();
        }, 100);
    }
});

// Compute nodes within given hop depth using allLinkData
function computeNodesWithinHops(startNodeId, maxHops) {
    const visited = new Set([startNodeId]);
    let frontier = [startNodeId];
    let hops = 0;
    while (frontier.length > 0 && hops < maxHops) {
        const nextFrontier = [];
        frontier.forEach(nodeId => {
            allLinkData.forEach(link => {
                if (link.from_node_id === nodeId && !visited.has(link.to_node_id)) {
                    visited.add(link.to_node_id);
                    nextFrontier.push(link.to_node_id);
                } else if (link.to_node_id === nodeId && !visited.has(link.from_node_id)) {
                    visited.add(link.from_node_id);
                    nextFrontier.push(link.from_node_id);
                }
            });
        });
        frontier = nextFrontier;
        hops += 1;
    }
    return visited;
}

// Draw network limited by hop depth around the selected node
function drawHopNetwork(skipFit = false) {
    if (selectedNodeId === null) {
        return;
    }

    // Determine visible nodes
    const visibleNodesSet = (currentHopDepth >= 999) ? new Set(nodeData.map(n => n.node_id)) : computeNodesWithinHops(selectedNodeId, currentHopDepth);
    visibleNodesSet.add(selectedNodeId); // ensure selected node visible

    // Backup full dataset
    const originalNodeData = [...nodeData];

    // Filter nodes for display
    nodeData = originalNodeData.filter(n => visibleNodesSet.has(n.node_id));

    // Re-render markers and links
    markerClusterGroup.clearLayers();
    nodeMarkers = [];

    // Clear existing links
    tracerouteLinks.forEach(l => map.removeLayer(l));
    tracerouteLinks = [];
    packetLinks.forEach(l => map.removeLayer(l));
    packetLinks = [];

    // Add markers
    nodeData.forEach(addNodeMarker);

    // Draw links restricted to visible nodes
    if (showTracerouteLinks) {
        if (currentHopDepth === 1) {
            drawFilteredTracerouteLinks(selectedNodeId);
        } else {
            drawTracerouteLinks();
        }
    }
    if (showPacketLinks) {
        if (currentHopDepth === 1) {
            drawFilteredPacketLinks(selectedNodeId);
        } else {
            drawPacketLinks();
        }
    }

    // Update node list display & stats
    displayNodeList(nodeData, false);
    updateStats();

    // Refit map unless caller requested otherwise
    if (!skipFit) {
        fitMapToNodes();
    }

    // Restore original data for other operations
    nodeData = originalNodeData;
}

// Auto-refresh functionality for map page
let autoRefreshInterval;
let isAutoRefreshEnabled = true;

function startAutoRefresh() {
    if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
    }

    autoRefreshInterval = setInterval(async () => {
        if (isAutoRefreshEnabled) {
            // Only log occasionally to reduce spam
            if (Math.random() < 0.1) { // 10% chance to log
                console.log('Auto-refreshing map data...');
            }
            await refreshMapData();
        }
    }, 3000); // 3 seconds

    console.log('Map auto-refresh started (every 3 seconds)');
}

function stopAutoRefresh() {
    if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
        console.log('Map auto-refresh stopped');
    }
}

async function refreshMapData() {
    try {
        // Store current map state
        const currentZoom = map.getZoom();
        const currentCenter = map.getCenter();
        const currentSelectedNode = selectedNodeId;
        const currentShowTraceroute = showTracerouteLinks;
        const currentShowPacket = showPacketLinks;

        // Store current filter values
        const form = document.getElementById('locationFilterForm');
        const formData = new FormData(form);
        const currentFilters = {
            startDate: formData.get('startDate'),
            endDate: formData.get('endDate'),
            minContacts: formData.get('minContacts'),
            gatewayId: formData.get('gatewayId'),
            search: formData.get('search')
        };

        // Reload data without showing loading indicator
        const params = buildFilterParams();
        const response = await fetch(`/api/locations?${params.toString()}`);
        const data = await response.json();

        if (data.error) {
            console.error('Error refreshing map data:', data.error);
            return;
        }

        // Update data
        allNodeData = data.locations || [];
        const tracerouteLinksFetched = (data.traceroute_links || []).map(l => ({ ...l, link_type: 'traceroute' }));
        const packetLinksFetched = (data.packet_links || []).map(l => ({ ...l, link_type: 'packet' }));
        // Merge traceroute and packet links, then drop links whose distance
        // exceeds the configured maximum.  This helps avoid impossible
        // long-range connections (e.g. thousands of km) that can appear
        // when packets are relayed over MQTT rather than direct RF.
        const combinedLinks = [...tracerouteLinksFetched, ...packetLinksFetched];
        allLinkData = combinedLinks.filter(l => {
            // If no distance is known, keep the link (to avoid hiding valid
            // connections where GPS data is missing)
            if (l.distance_km === undefined || l.distance_km === null) {
                return true;
            }

            // If distance is within normal range, keep it
            if (l.distance_km <= MAX_LINK_DISTANCE_KM) {
                return true;
            }

            // For links beyond max distance, check if they have valid SNR/RSSI values
            // indicating a real RF connection (not MQTT)
            const hasValidSNR = l.avg_snr !== null && l.avg_snr !== undefined &&
                               l.avg_snr > -20 && l.avg_snr < 20;  // Reasonable SNR range
            const hasValidRSSI = l.avg_rssi !== null && l.avg_rssi !== undefined &&
                                l.avg_rssi > -140 && l.avg_rssi < 0;  // Reasonable RSSI range

            // Keep the link if it has valid signal measurements, even if distance is large
            return hasValidSNR && hasValidRSSI;
        });

        // Apply filters and update display
        applyClientSideFilters();

        // Restore map state
        map.setView(currentCenter, currentZoom);
        selectedNodeId = currentSelectedNode;
        showTracerouteLinks = currentShowTraceroute;
        showPacketLinks = currentShowPacket;

        // Update link visibility.  When a node is selected the call to
        // drawHopNetwork() will normally refit the map to include all visible
        // nodes.  This resets the user's zoom/center on every refresh.  Pass
        // `true` to skip fitting so the current view remains intact.
        if (selectedNodeId !== null) {
            drawHopNetwork(true);
        } else {
            if (showTracerouteLinks) {
                drawTracerouteLinks();
            }
            if (showPacketLinks) {
                drawPacketLinks();
            }
        }

        // Only log occasionally to reduce spam
        if (Math.random() < 0.1) { // 10% chance to log
            console.log('Map data refreshed successfully');
        }

    } catch (error) {
        console.error('Error refreshing map data:', error);
    }
}

// -------------------------------------------------------------------
// Live Packet Streaming and Node/Cluster Flashing
// -------------------------------------------------------------------

/**
 * Highlight a node or its cluster on the map when a live packet event occurs.
 *
 * @param {number|string} nodeId - The numeric node ID from the live packet data.
 * @param {string} color - 'green' for transmitters (broadcast) or 'red' for receivers.
 */
function flashNode(nodeId, color) {
    // Normalize the ID to a number for consistent map lookup keys
    const idKey = typeof nodeId === 'string' ? parseInt(nodeId, 10) : nodeId;
    const marker = nodeMarkerMap[idKey];
    if (!marker) {
        // No marker is currently displayed for this node (may be filtered out)
        return;
    }
    // Determine the element to highlight: either the marker itself or its cluster
    let element = null;
    let isCluster = false;
    try {
        // Retrieve visible parent of the marker; if the marker is clustered,
        // this will return the cluster icon instead of the marker.  Otherwise
        // returns the marker itself.
        const parent = markerClusterGroup.getVisibleParent(marker);
        if (parent && typeof parent.getChildCount === 'function' && parent.getChildCount() > 1) {
            // It's a cluster; highlight the cluster icon
            element = parent._icon;
            isCluster = true;
        } else {
            // Use the marker's DOM element
            element = marker.getElement();
        }
    } catch (e) {
        // Fallback to marker element on any unexpected error
        element = marker.getElement();
    }
    if (!element) return;

    // Remove any existing animation classes
    element.classList.remove('transmitting-marker', 'receiving-marker', 'transmitting-cluster', 'receiving-cluster');

    // Force reflow to restart animation
    void element.offsetWidth;

    // Apply appropriate animation class based on color and element type
    let animationClass;
    if (isCluster) {
        animationClass = color === 'red' ? 'receiving-cluster' : 'transmitting-cluster';
    } else {
        animationClass = color === 'red' ? 'receiving-marker' : 'transmitting-marker';
    }

    element.classList.add(animationClass);

    // Remove animation class after animation completes
    setTimeout(() => {
        element.classList.remove(animationClass);
    }, 1200);
}

/**
 * Establish a Server-Sent Events connection to the /stream/packets endpoint.
 * Each packet will cause the originating node to flash green and the destination
 * node to flash red on the map.  If a node is currently in a cluster, the
 * cluster icon will be highlighted instead.
 */
function connectLiveStream() {
    try {
        const src = new EventSource('/stream/packets');
        src.addEventListener('ping', () => console.log('[map] live ping'));
        src.onmessage = (e) => {
            try {
                const data = JSON.parse(e.data);
                // data.from and data.to contain numeric node IDs; flash accordingly
                if (data.from !== undefined && data.from !== null) {
                    flashNode(data.from, 'green');
                }
                if (data.to !== undefined && data.to !== null) {
                    flashNode(data.to, 'red');
                }
            } catch (err) {
                console.warn('Error parsing live packet data', err);
            }
        };
    } catch (e) {
        console.warn('EventSource unsupported or failed to connect', e);
    }
}

// Start auto-refresh when page loads
document.addEventListener('DOMContentLoaded', function() {
    // Start auto-refresh after initial load
    setTimeout(() => {
        startAutoRefresh();
    }, 1000); // Wait 1 second after initial load
});

// Stop auto-refresh when user navigates away
window.addEventListener('beforeunload', function() {
    stopAutoRefresh();
});

// Toggle auto-refresh with keyboard shortcut (Ctrl+R)
document.addEventListener('keydown', function(e) {
    if (e.ctrlKey && e.key === 'r') {
        e.preventDefault();
        isAutoRefreshEnabled = !isAutoRefreshEnabled;
        if (isAutoRefreshEnabled) {
            startAutoRefresh();
            console.log('Auto-refresh enabled');
        } else {
            stopAutoRefresh();
            console.log('Auto-refresh disabled');
        }
    }
});
</script>
{% endblock %}

</div> <!-- Close the full-width container -->
<!-- Reopen the base template's container for the footer -->
<div class="container mt-4">
