{% extends "base.html" %}
{% from "components/table_layout_macros.html" import fullscreen_table_container, filter_section, table_controls_section, table_stats_section, table_layout_styles %}

{% block title %}Nodes - Malla{% endblock %}

{% block extra_css %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/modern-table.css') }}">
{{ table_layout_styles() }}
<style>
    /* Items per page selector styling */
    .page-size-selector {
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .page-size-selector label {
        margin: 0;
        font-size: 0.875rem;
    }

    .page-size-selector select {
        width: auto;
        min-width: 80px;
    }

    /* Enhanced pagination styling */
    .modern-pagination {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem;
        border-top: 1px solid #dee2e6;
        background: #f8f9fa;
    }

    .pagination-controls {
        display: flex;
        gap: 0.25rem;
        align-items: center;
    }

    .pagination-btn {
        padding: 0.375rem 0.75rem;
        border: 1px solid #dee2e6;
        background: white;
        color: #495057;
        border-radius: 0.25rem;
        font-size: 0.875rem;
        cursor: pointer;
        transition: all 0.15s ease;
    }

    .pagination-btn:hover:not(:disabled) {
        background: #e9ecef;
        border-color: #adb5bd;
    }

    .pagination-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    .pagination-btn.active {
        background: #0d6efd;
        color: white;
        border-color: #0d6efd;
    }

    .pagination-info {
        font-size: 0.875rem;
        color: #6c757d;
    }

    /* Items per page in pagination area */
    .items-per-page-control {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.875rem;
    }
</style>
{% endblock %}

{% block content %}
<!-- Override the base template's container to make this page full-width/full-height -->
</div> <!-- Close the base template's container -->

{% call fullscreen_table_container("nodesTable", "Network Nodes", "bi bi-diagram-3", "toggleSidebar") %}
    <!-- Main table content -->
    <div id="nodesTable" class="modern-table-container"></div>
{% endcall %}

<!-- Sidebar content (will be injected into the sidebar) -->
<div id="sidebarContent" style="display: none;">
    {% call filter_section("filtersForm", "Node Filters") %}
        <div class="row g-3">
            <div class="col-12">
                <label for="search" class="form-label">Search</label>
                <input type="text" class="form-control form-control-sm" id="search" name="search" placeholder="Search by name, ID, or hardware...">
            </div>
            <div class="col-12">
                <label for="role" class="form-label">Role</label>
                <select class="form-select form-select-sm" id="role" name="role">
                    <option value="">All Roles</option>
                    <!-- Options will be loaded dynamically -->
                </select>
            </div>
            <div class="col-12">
                <label for="hw_model" class="form-label">Hardware Model</label>
                <select class="form-select form-select-sm" id="hw_model" name="hw_model">
                    <option value="">All Hardware</option>
                    <!-- Options will be loaded dynamically -->
                </select>
            </div>
            <div class="col-12">
                <label for="primary_channel" class="form-label">Primary Channel</label>
                <select class="form-select form-select-sm" id="primary_channel" name="primary_channel">
                    <option value="">All Channels</option>
                    <!-- Options will be loaded dynamically -->
                </select>
            </div>
            <div class="col-12">
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="active_only" name="active_only">
                    <label class="form-check-label" for="active_only">
                        Active nodes only (24h)
                    </label>
                </div>
            </div>
            <div class="col-12">
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="named_only" name="named_only">
                    <label class="form-check-label" for="named_only">
                        Named nodes only
                    </label>
                </div>
            </div>
        </div>
    {% endcall %}

    {% call table_controls_section() %}
        <button class="btn btn-primary btn-sm w-100" id="applyFilters">
            <i class="bi bi-funnel"></i> Apply Filters
        </button>
        <button class="btn btn-secondary btn-sm w-100 mt-2" id="clearFilters">
            <i class="bi bi-x-circle"></i> Clear Filters
        </button>
        <button class="btn btn-outline-primary btn-sm w-100 mt-2" id="refreshTable">
            <i class="bi bi-arrow-clockwise"></i> Refresh
        </button>
    {% endcall %}
</div>

<!-- Re-open the container div that we closed at the beginning -->
<div class="container-fluid">
{% endblock %}

{% block extra_js %}
<script src="{{ url_for('static', filename='js/modern-table.js') }}"></script>
<script src="{{ url_for('static', filename='js/url-manager.js') }}"></script>
<script src="{{ url_for('static', filename='js/table-filter-controller.js') }}"></script>
<script src="{{ url_for('static', filename='js/sidebar.js') }}"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // Initialize URL manager
    const urlManager = new URLManager();

    // Load hardware models from API
    async function loadHardwareModels() {
        try {
            const response = await fetch('/api/meshtastic/hardware-models');
            const data = await response.json();

            if (data.hardware_models) {
                const select = document.getElementById('hw_model');
                // Clear existing options except the first one
                select.innerHTML = '<option value="">All Hardware</option>';

                data.hardware_models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    select.appendChild(option);
                });
            }
        } catch (error) {
            console.error('Error loading hardware models:', error);
        }
    }

    // Load node roles from API
    async function loadNodeRoles() {
        try {
            const response = await fetch('/api/meshtastic/node-roles');
            const data = await response.json();

            if (data.node_roles) {
                const select = document.getElementById('role');
                // Clear existing options except the first one
                select.innerHTML = '<option value="">All Roles</option>';

                data.node_roles.forEach(role => {
                    const option = document.createElement('option');
                    option.value = role;
                    option.textContent = role;
                    select.appendChild(option);
                });
            }
        } catch (error) {
            console.error('Error loading node roles:', error);
        }
    }

    // Load primary channels from API
    async function loadPrimaryChannels() {
        try {
            const response = await fetch('/api/meshtastic/channels');
            const data = await response.json();

            if (data.channels) {
                const select = document.getElementById('primary_channel');
                // Clear existing options except the first one
                select.innerHTML = '<option value="">All Channels</option>';

                data.channels.forEach(channel => {
                    const option = document.createElement('option');
                    option.value = channel;
                    option.textContent = `Channel ${channel}`;
                    select.appendChild(option);
                });
            }
        } catch (error) {
            console.error('Error loading primary channels:', error);
        }
    }

    // Get dynamic columns configuration
    function getDynamicColumns() {
        return [
            {
                key: 'hex_id',
                title: 'Node ID',
                sortable: true,
                render: (value, row) => {
                    return `<a href="/node/${row.node_id}" class="text-decoration-none font-monospace" title="View node details">
                                <small>${value}</small>
                            </a>`;
                }
            },
            {
                key: 'long_name',
                title: 'Name',
                sortable: true,
                render: (value, row) => {
                    const displayName = value || row.short_name || 'Unknown';
                    return `<div>${displayName}</div>`;
                }
            },
            {
                key: 'hw_model',
                title: 'Hardware',
                sortable: true,
                render: (value) => value || '<span class="text-muted">Unknown</span>'
            },
            {
                key: 'role',
                title: 'Role',
                sortable: true,
                type: 'badge',
                badgeMap: {
                    'CLIENT': 'modern-badge-primary',
                    'CLIENT_MUTE': 'modern-badge-secondary',
                    'ROUTER': 'modern-badge-success',
                    'ROUTER_CLIENT': 'modern-badge-info',
                    'REPEATER': 'modern-badge-warning',
                    'TRACKER': 'modern-badge-dark'
                }
            },
            {
                key: 'battery_level',
                title: 'Battery',
                sortable: true,
                render: (value) => {
                    if (value === null || value === undefined) {
                        return '<span class="text-muted">N/A</span>';
                    }
                    let color = 'text-success';
                    if (value < 20) color = 'text-danger';
                    else if (value < 50) color = 'text-warning';
                    return `<span class="${color}">${value}%</span>`;
                }
            },
            {
                key: 'last_packet_str',
                title: 'Last Seen',
                sortable: true,
                sortKey: 'last_packet_time',
                render: (value, row) => {
                    if (!row.last_packet_time) {
                        return '<span class="text-muted">Never</span>';
                    }
                    // Use the pre-formatted string from the backend
                    const ageClass = row.age_hours < 1 ? 'text-success' :
                                   row.age_hours < 24 ? 'text-warning' : 'text-muted';
                    return `<span class="${ageClass}" title="${row.last_packet_time}">${value}</span>`;
                }
            },
            {
                key: 'packet_count_24h',
                title: '24h Packets',
                sortable: true,
                render: (value) => {
                    if (!value) return '<span class="text-muted">0</span>';
                    return `<span class="badge bg-primary">${value}</span>`;
                }
            },
            {
                key: 'actions',
                title: 'Actions',
                type: 'actions',
                actions: [
                    {
                        icon: 'eye',
                        title: 'View details',
                        url: '/node/{id}',
                        class: 'text-primary'
                    }
                ]
            }
        ];
    }

    // Initialize the modern table with proper server-side pagination
    const table = new ModernTable('nodesTable', {
        endpoint: '/api/nodes/data',
        enableSearch: false,  // We handle search through filters
        enablePagination: true,
        pageSize: 25,
        deferInitialLoad: true,
        columns: getDynamicColumns()
    });

    // Override the renderPagination method to include items per page dropdown
    const originalRenderPagination = table.renderPagination.bind(table);
    table.renderPagination = function() {
        return `
            <div class="modern-pagination">
                <div class="pagination-info">
                    Showing <span id="${this.container.id}-start">0</span> to <span id="${this.container.id}-end">0</span>
                    of <span id="${this.container.id}-total">0</span> entries
                </div>
                <div class="pagination-controls" id="${this.container.id}-pagination">
                    <!-- Pagination buttons will be rendered here -->
                </div>
                <div class="items-per-page-control">
                    <label for="${this.container.id}-items-per-page">Items per page:</label>
                    <select id="${this.container.id}-items-per-page" class="form-select form-select-sm">
                        <option value="5">5</option>
                        <option value="10">10</option>
                        <option value="25" selected>25</option>
                        <option value="50">50</option>
                        <option value="100">100</option>
                    </select>
                </div>
            </div>
        `;
    };

    // Add items per page change handler after table initialization
    const originalSetupEventListeners = table.setupEventListeners.bind(table);
    table.setupEventListeners = function() {
        originalSetupEventListeners();

        // Add items per page selector
        const itemsPerPageSelect = document.getElementById(`${this.container.id}-items-per-page`);
        if (itemsPerPageSelect) {
            itemsPerPageSelect.addEventListener('change', (e) => {
                this.state.pageSize = parseInt(e.target.value);
                this.state.page = 1;
                this.loadData();
            });
        }
    };

    // Update stats function
    function updateStats() {
        // Stats functionality can be added here if needed
    }

    // Initialize the filter controller
    const controller = new TableFilterController({
        table,
        urlManager,
        formSelector: '#filtersForm',
        updateStats
    });

    // Expose controller methods to global scope for testing/debugging
    window.applyCurrentFilters = () => controller.applyCurrentFilters();
    window.controller = controller;

    // Button handlers
    const applyFiltersBtn = document.getElementById('applyFilters');
    const clearFiltersBtn = document.getElementById('clearFilters');
    const refreshBtn = document.getElementById('refreshTable');

    applyFiltersBtn.addEventListener('click', () => controller.applyCurrentFilters());
    clearFiltersBtn.addEventListener('click', () => controller.clearFilters());
    refreshBtn.addEventListener('click', () => {
        table.loadData();
    });

    // Initialize page with filters and load data
    async function initializePageWithFilters() {
        // Apply URL parameters
        const hasParams = await urlManager.applyURLParameters();

        // Initialize the filter controller
        controller.initialLoad(hasParams);
    }

    // Load supporting data then initialize
    Promise.all([loadHardwareModels(), loadNodeRoles(), loadPrimaryChannels()]).then(async () => {
        initializePageWithFilters();
    });

    // Initialize tooltips after table loads
    table.on('dataLoaded', function() {
        // Initialize Bootstrap tooltips
        const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
        tooltipTriggerList.map(function (tooltipTriggerEl) {
            return new bootstrap.Tooltip(tooltipTriggerEl);
        });
    });
});
</script>
{% endblock %}